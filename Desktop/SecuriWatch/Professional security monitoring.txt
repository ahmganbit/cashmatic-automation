#!/usr/bin/env python3
"""
SecurityWatch Pro - Advanced Failed Login Security Analyzer
Copyright (c) 2025 SysAdmin Tools Pro
Version: 1.0.0

Professional security monitoring with intelligent pattern recognition, automated threat detection,
and comprehensive reporting for Windows, Linux, and macOS systems.
"""

import os
import sys
import json
import re
import smtplib
import logging
import time
import argparse
import sqlite3
from datetime import datetime, timedelta
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Set
from collections import defaultdict, Counter
from dataclasses import dataclass, asdict
import threading
import schedule
import ipaddress
import socket
from cryptography.fernet import Fernet
import base64
import hashlib
import subprocess
import platform

# Version and metadata
__version__ = "1.0.0"
__author__ = "SysAdmin Tools Pro"
__email__ = "support@sysadmintoolspro.com"

@dataclass
class SecurityEvent:
    """Individual security event data structure"""
    timestamp: datetime
    event_type: str  # failed_login, brute_force, suspicious_ip, etc.
    source_ip: str
    username: str
    hostname: str
    details: str
    severity: str  # low, medium, high, critical
    log_source: str

@dataclass
class ThreatPattern:
    """Threat pattern configuration"""
    name: str
    description: str
    regex_pattern: str
    severity: str
    enabled: bool = True
    threshold_count: int = 5
    time_window: int = 300  # seconds

@dataclass
class AlertConfig:
    """Alert configuration settings"""
    email_enabled: bool = True
    console_enabled: bool = True
    log_enabled: bool = True
    report_enabled: bool = True
    alert_frequency: int = 15  # Minutes between alerts
    severity_threshold: str = "medium"  # minimum severity to alert

@dataclass
class EmailConfig:
    """Email configuration with encryption"""
    smtp_server: str = ""
    smtp_port: int = 587
    username: str = ""
    password: str = ""  # Will be encrypted
    from_email: str = ""
    to_emails: List[str] = None
    use_tls: bool = True
    enabled: bool = False

@dataclass
class MonitoringConfig:
    """System monitoring configuration"""
    log_paths: List[str] = None
    check_interval: int = 60  # seconds
    max_events_memory: int = 10000
    database_retention_days: int = 30
    auto_detect_logs: bool = True
    monitor_system_events: bool = True

class SecurityDatabase:
    """SQLite database for storing security events"""
    
    def __init__(self, db_path: str = "securitywatch.db"):
        self.db_path = Path(db_path)
        self.init_database()
    
    def init_database(self):
        """Initialize database with required tables"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Events table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS security_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                event_type TEXT NOT NULL,
                source_ip TEXT,
                username TEXT,
                hostname TEXT,
                details TEXT,
                severity TEXT NOT NULL,
                log_source TEXT,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Threat patterns table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS threat_patterns (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT UNIQUE NOT NULL,
                pattern TEXT NOT NULL,
                severity TEXT NOT NULL,
                threshold_count INTEGER DEFAULT 5,
                time_window INTEGER DEFAULT 300,
                enabled BOOLEAN DEFAULT 1,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # IP reputation table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS ip_reputation (
                ip_address TEXT PRIMARY KEY,
                reputation_score INTEGER DEFAULT 0,
                first_seen TEXT,
                last_seen TEXT,
                event_count INTEGER DEFAULT 0,
                is_blocked BOOLEAN DEFAULT 0
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def add_event(self, event: SecurityEvent):
        """Add security event to database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO security_events 
            (timestamp, event_type, source_ip, username, hostname, details, severity, log_source)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            event.timestamp.isoformat(),
            event.event_type,
            event.source_ip,
            event.username,
            event.hostname,
            event.details,
            event.severity,
            event.log_source
        ))
        
        conn.commit()
        conn.close()
    
    def get_recent_events(self, hours: int = 24) -> List[SecurityEvent]:
        """Get events from the last N hours"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        since = datetime.now() - timedelta(hours=hours)
        cursor.execute('''
            SELECT timestamp, event_type, source_ip, username, hostname, details, severity, log_source
            FROM security_events 
            WHERE timestamp > ?
            ORDER BY timestamp DESC
        ''', (since.isoformat(),))
        
        events = []
        for row in cursor.fetchall():
            events.append(SecurityEvent(
                timestamp=datetime.fromisoformat(row[0]),
                event_type=row[1],
                source_ip=row[2] or "",
                username=row[3] or "",
                hostname=row[4] or "",
                details=row[5] or "",
                severity=row[6],
                log_source=row[7] or ""
            ))
        
        conn.close()
        return events
    
    def update_ip_reputation(self, ip: str, severity: str):
        """Update IP reputation based on events"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Score mapping
        score_map = {"low": 1, "medium": 5, "high": 10, "critical": 20}
        score = score_map.get(severity, 1)
        
        cursor.execute('''
            INSERT OR REPLACE INTO ip_reputation 
            (ip_address, reputation_score, first_seen, last_seen, event_count, is_blocked)
            VALUES (
                ?, 
                COALESCE((SELECT reputation_score FROM ip_reputation WHERE ip_address = ?), 0) + ?,
                COALESCE((SELECT first_seen FROM ip_reputation WHERE ip_address = ?), ?),
                ?,
                COALESCE((SELECT event_count FROM ip_reputation WHERE ip_address = ?), 0) + 1,
                CASE WHEN COALESCE((SELECT reputation_score FROM ip_reputation WHERE ip_address = ?), 0) + ? > 50 THEN 1 ELSE 0 END
            )
        ''', (ip, ip, score, ip, datetime.now().isoformat(), datetime.now().isoformat(), ip, ip, score))
        
        conn.commit()
        conn.close()
    
    def cleanup_old_events(self, days: int):
        """Remove events older than specified days"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cutoff = datetime.now() - timedelta(days=days)
        cursor.execute('DELETE FROM security_events WHERE timestamp < ?', (cutoff.isoformat(),))
        
        deleted = cursor.rowcount
        conn.commit()
        conn.close()
        
        return deleted

class LogPatternMatcher:
    """Advanced pattern matching for security events"""
    
    def __init__(self):
        self.patterns = self._initialize_patterns()
    
    def _initialize_patterns(self) -> List[ThreatPattern]:
        """Initialize default threat patterns"""
        return [
            # SSH Failed Login Patterns
            ThreatPattern(
                name="SSH Failed Login",
                description="Failed SSH authentication attempts",
                regex_pattern=r"Failed password for (?P<username>\S+) from (?P<ip>\d+\.\d+\.\d+\.\d+)",
                severity="medium"
            ),
            ThreatPattern(
                name="SSH Invalid User",
                description="SSH login attempts with invalid usernames",
                regex_pattern=r"Invalid user (?P<username>\S+) from (?P<ip>\d+\.\d+\.\d+\.\d+)",
                severity="high"
            ),
            
            # Windows Failed Login Patterns
            ThreatPattern(
                name="Windows Failed Login",
                description="Windows logon failures",
                regex_pattern=r"Logon Type:\s+(?P<logon_type>\d+).*Source Network Address:\s+(?P<ip>\d+\.\d+\.\d+\.\d+).*Account Name:\s+(?P<username>\S+)",
                severity="medium"
            ),
            
            # Brute Force Patterns
            ThreatPattern(
                name="Rapid Failed Logins",
                description="Multiple failed login attempts in short time",
                regex_pattern=r"authentication failure.*user=(?P<username>\S+)",
                severity="high",
                threshold_count=10,
                time_window=300
            ),
            
            # Web Application Attacks
            ThreatPattern(
                name="SQL Injection Attempt",
                description="Potential SQL injection in web logs",
                regex_pattern=r"(?P<ip>\d+\.\d+\.\d+\.\d+).*(?:union|select|insert|delete|drop|exec).*(?:'|--|;)",
                severity="critical"
            ),
            
            # System Intrusion
            ThreatPattern(
                name="Privilege Escalation",
                description="Potential privilege escalation attempts",
                regex_pattern=r"(?P<username>\S+).*(?:sudo|su|admin|root).*(?:FAILED|denied)",
                severity="high"
            ),
            
            # Network Scanning
            ThreatPattern(
                name="Port Scanning",
                description="Potential port scanning activity",
                regex_pattern=r"(?P<ip>\d+\.\d+\.\d+\.\d+).*(?:connection refused|timeout|unreachable)",
                severity="medium",
                threshold_count=20
            )
        ]
    
    def match_patterns(self, log_line: str, log_source: str) -> List[SecurityEvent]:
        """Match log line against all threat patterns"""
        events = []
        
        for pattern in self.patterns:
            if not pattern.enabled:
                continue
            
            match = re.search(pattern.regex_pattern, log_line, re.IGNORECASE)
            if match:
                event = SecurityEvent(
                    timestamp=datetime.now(),
                    event_type=pattern.name.lower().replace(' ', '_'),
                    source_ip=match.groupdict().get('ip', ''),
                    username=match.groupdict().get('username', ''),
                    hostname=socket.gethostname(),
                    details=log_line.strip(),
                    severity=pattern.severity,
                    log_source=log_source
                )
                events.append(event)
        
        return events

class ThreatAnalyzer:
    """Advanced threat analysis and correlation"""
    
    def __init__(self, database: SecurityDatabase):
        self.database = database
        self.event_cache = defaultdict(list)
    
    def analyze_events(self, events: List[SecurityEvent]) -> Dict[str, any]:
        """Perform comprehensive threat analysis"""
        analysis = {
            'total_events': len(events),
            'severity_breakdown': Counter(),
            'top_source_ips': Counter(),
            'top_usernames': Counter(),
            'attack_patterns': [],
            'brute_force_attempts': [],
            'geographic_analysis': {},
            'recommendations': []
        }
        
        # Basic statistics
        for event in events:
            analysis['severity_breakdown'][event.severity] += 1
            if event.source_ip:
                analysis['top_source_ips'][event.source_ip] += 1
            if event.username:
                analysis['top_usernames'][event.username] += 1
        
        # Detect brute force attacks
        analysis['brute_force_attempts'] = self._detect_brute_force(events)
        
        # Generate recommendations
        analysis['recommendations'] = self._generate_recommendations(analysis)
        
        return analysis
    
    def _detect_brute_force(self, events: List[SecurityEvent]) -> List[Dict]:
        """Detect brute force attack patterns"""
        brute_force_attacks = []
        
        # Group events by IP and time window
        ip_events = defaultdict(list)
        for event in events:
            if event.source_ip and event.event_type in ['ssh_failed_login', 'windows_failed_login']:
                ip_events[event.source_ip].append(event)
        
        # Analyze each IP for brute force patterns
        for ip, ip_event_list in ip_events.items():
            if len(ip_event_list) >= 5:  # Threshold for brute force
                # Check if events are within time window
                timestamps = [e.timestamp for e in ip_event_list]
                timestamps.sort()
                
                time_span = (timestamps[-1] - timestamps[0]).total_seconds()
                if time_span <= 600:  # 10 minutes
                    brute_force_attacks.append({
                        'source_ip': ip,
                        'attempt_count': len(ip_event_list),
                        'time_span_seconds': time_span,
                        'usernames_targeted': list(set(e.username for e in ip_event_list if e.username)),
                        'first_attempt': timestamps[0],
                        'last_attempt': timestamps[-1],
                        'severity': 'critical' if len(ip_event_list) > 20 else 'high'
                    })
        
        return brute_force_attacks
    
    def _generate_recommendations(self, analysis: Dict) -> List[str]:
        """Generate actionable security recommendations"""
        recommendations = []
        
        # High number of failed logins
        if analysis['total_events'] > 100:
            recommendations.append("Consider implementing rate limiting or account lockout policies")
        
        # Brute force attacks detected
        if analysis['brute_force_attempts']:
            recommendations.append("Implement fail2ban or similar IP blocking mechanisms")
            recommendations.append("Consider changing default SSH port and disabling root login")
        
        # High severity events
        if analysis['severity_breakdown']['critical'] > 0:
            recommendations.append("Investigate critical security events immediately")
        
        # Top attacking IPs
        if analysis['top_source_ips']:
            top_ip = analysis['top_source_ips'].most_common(1)[0]
            if top_ip[1] > 10:
                recommendations.append(f"Consider blocking IP {top_ip[0]} (repeated offender)")
        
        return recommendations

class SecurityWatchConfig:
    """Configuration management for SecurityWatch Pro"""
    
    def __init__(self, config_file: str = "securitywatch_config.json"):
        self.config_file = Path(config_file)
        self.encryption_key = None
        self._load_or_create_config()
    
    def _generate_key(self) -> bytes:
        """Generate encryption key from system info"""
        system_info = f"{os.getlogin()}{platform.node()}SecurityWatchPro"
        return base64.urlsafe_b64encode(hashlib.sha256(system_info.encode()).digest())
    
    def _encrypt_password(self, password: str) -> str:
        """Encrypt password for secure storage"""
        if not self.encryption_key:
            self.encryption_key = self._generate_key()
        
        fernet = Fernet(self.encryption_key)
        return fernet.encrypt(password.encode()).decode()
    
    def _decrypt_password(self, encrypted_password: str) -> str:
        """Decrypt password for use"""
        if not self.encryption_key:
            self.encryption_key = self._generate_key()
        
        try:
            fernet = Fernet(self.encryption_key)
            return fernet.decrypt(encrypted_password.encode()).decode()
        except Exception:
            return ""
    
    def _load_or_create_config(self):
        """Load existing config or create default"""
        if self.config_file.exists():
            try:
                with open(self.config_file, 'r') as f:
                    config_data = json.load(f)
                    self._parse_config(config_data)
            except Exception as e:
                print(f"Error loading config: {e}")
                self._create_default_config()
        else:
            self._create_default_config()
    
    def _create_default_config(self):
        """Create default configuration"""
        self.email = EmailConfig(to_emails=[])
        self.alerts = AlertConfig()
        self.monitoring = MonitoringConfig()
        
        # Auto-detect log paths based on OS
        self.monitoring.log_paths = self._detect_log_paths()
        
        self.save_config()
    
    def _detect_log_paths(self) -> List[str]:
        """Auto-detect system log paths"""
        system = platform.system().lower()
        log_paths = []
        
        if system == "linux":
            potential_paths = [
                "/var/log/auth.log",      # Ubuntu/Debian
                "/var/log/secure",        # CentOS/RHEL
                "/var/log/messages",      # General system logs
                "/var/log/syslog",        # Ubuntu/Debian syslog
                "/var/log/httpd/access_log",  # Apache
                "/var/log/apache2/access.log", # Apache Ubuntu
                "/var/log/nginx/access.log"   # Nginx
            ]
        elif system == "darwin":  # macOS
            potential_paths = [
                "/var/log/system.log",
                "/var/log/auth.log",
                "/private/var/log/secure.log"
            ]
        elif system == "windows":
            potential_paths = [
                "C:\\Windows\\System32\\winevt\\Logs\\Security.evtx",
                "C:\\Windows\\System32\\winevt\\Logs\\System.evtx"
            ]
        
        # Check which paths exist
        for path in potential_paths:
            if Path(path).exists():
                log_paths.append(path)
        
        return log_paths
    
    def _parse_config(self, config_data: dict):
        """Parse configuration from JSON"""
        # Parse email config
        email_data = config_data.get('email', {})
        if 'password' in email_data and email_data['password']:
            email_data['password'] = self._decrypt_password(email_data['password'])
        self.email = EmailConfig(**email_data)
        
        # Parse other configs
        self.alerts = AlertConfig(**config_data.get('alerts', {}))
        
        monitoring_data = config_data.get('monitoring', {})
        if 'log_paths' not in monitoring_data:
            monitoring_data['log_paths'] = self._detect_log_paths()
        self.monitoring = MonitoringConfig(**monitoring_data)
    
    def save_config(self):
        """Save configuration to file"""
        config_data = {
            'email': asdict(self.email),
            'alerts': asdict(self.alerts),
            'monitoring': asdict(self.monitoring)
        }
        
        # Encrypt password before saving
        if config_data['email']['password']:
            config_data['email']['password'] = self._encrypt_password(config_data['email']['password'])
        
        try:
            with open(self.config_file, 'w') as f:
                json.dump(config_data, f, indent=2)
        except Exception as e:
            print(f"Error saving config: {e}")

class SecurityWatchMonitor:
    """Main monitoring engine for SecurityWatch Pro"""
    
    def __init__(self, config: SecurityWatchConfig):
        self.config = config
        self.database = SecurityDatabase()
        self.pattern_matcher = LogPatternMatcher()
        self.threat_analyzer = ThreatAnalyzer(self.database)
        self.logger = self._setup_logging()
        self.running = False
        self.log_positions = {}  # Track file positions
        
    def _setup_logging(self) -> logging.Logger:
        """Setup enterprise-grade logging"""
        logger = logging.getLogger('SecurityWatchPro')
        logger.setLevel(logging.INFO)
        
        # Create logs directory
        log_dir = Path('logs')
        log_dir.mkdir(exist_ok=True)
        
        # File handler
        file_handler = logging.FileHandler(log_dir / 'securitywatch.log')
        console_handler = logging.StreamHandler()
        
        # Formatter
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        file_handler.setFormatter(formatter)
        console_handler.setFormatter(formatter)
        
        logger.addHandler(file_handler)
        logger.addHandler(console_handler)
        
        return logger
    
    def monitor_log_file(self, log_path: str) -> List[SecurityEvent]:
        """Monitor a single log file for new entries"""
        events = []
        
        try:
            if not Path(log_path).exists():
                return events
            
            # Get current file position
            current_pos = self.log_positions.get(log_path, 0)
            
            with open(log_path, 'r', encoding='utf-8', errors='ignore') as f:
                f.seek(current_pos)
                new_lines = f.readlines()
                self.log_positions[log_path] = f.tell()
            
            # Process new lines
            for line in new_lines:
                line = line.strip()
                if line:
                    matched_events = self.pattern_matcher.match_patterns(line, log_path)
                    events.extend(matched_events)
            
        except Exception as e:
            self.logger.error(f"Error monitoring {log_path}: {e}")
        
        return events
    
    def check_all_logs(self) -> List[SecurityEvent]:
        """Check all configured log files"""
        all_events = []
        
        for log_path in self.config.monitoring.log_paths:
            events = self.monitor_log_file(log_path)
            all_events.extend(events)
        
        # Store events in database
        for event in all_events:
            self.database.add_event(event)
            if event.source_ip:
                self.database.update_ip_reputation(event.source_ip, event.severity)
        
        return all_events
    
    def generate_security_report(self) -> str:
        """Generate comprehensive security report"""
        # Get recent events
        recent_events = self.database.get_recent_events(24)
        
        # Analyze threats
        analysis = self.threat_analyzer.analyze_events(recent_events)
        
        # Generate HTML report
        html_report = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>SecurityWatch Pro Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }}
                .header {{ background: #c0392b; color: white; padding: 20px; border-radius: 5px; margin-bottom: 20px; }}
                .summary {{ background: white; padding: 20px; border-radius: 5px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
                .alert {{ background: #e74c3c; color: white; padding: 15px; margin: 10px 0; border-radius: 5px; }}
                .warning {{ background: #f39c12; color: white; padding: 15px; margin: 10px 0; border-radius: 5px; }}
                .info {{ background: #3498db; color: white; padding: 15px; margin: 10px 0; border-radius: 5px; }}
                .table {{ width: 100%; border-collapse: collapse; margin: 20px 0; background: white; }}
                .table th, .table td {{ border: 1px solid #ddd; padding: 12px; text-align: left; }}
                .table th {{ background-color: #34495e; color: white; }}
                .recommendations {{ background: #2ecc71; color: white; padding: 20px; border-radius: 5px; margin: 20px 0; }}
                .chart {{ background: white; padding: 20px; border-radius: 5px; margin: 20px 0; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>🛡️ SecurityWatch Pro Report</h1>
                <p>Security Analysis Report - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            </div>
            
            <div class="summary">
                <h2>📊 Executive Summary</h2>
                <p><strong>Total Security Events:</strong> {analysis['total_events']}</p>
                <p><strong>Critical Events:</strong> {analysis['severity_breakdown']['critical']}</p>
                <p><strong>High Severity:</strong> {analysis['severity_breakdown']['high']}</p>
                <p><strong>Brute Force Attempts:</strong> {len(analysis['brute_force_attempts'])}</p>
            </div>
        """
        
        # Brute force attacks section
        if analysis['brute_force_attempts']:
            html_report += """
            <div class="alert">
                <h2>